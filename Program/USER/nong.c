///////////////////////////////////////////////////////////////////////////////
//
//
//
///////////////////////////////////////////////////////////////////////////////
#include "MESSAGE.h"

unsigned char code year_code[]={ 
    /*	 
    0x04,0xAe,0x53,0x0A,0x57,0x48,0x55,0x26,0xBd, // 1901-1903 
    0x0d,0x26,0x50,0x0d,0x95,0x44,0x46,0xAA,0xB9, // 1904-1906 
    0x05,0x6A,0x4d,0x09,0xAd,0x42,0x24,0xAe,0xB6, // 1907-1909 
    0x04,0xAe,0x4A,0x6A,0x4d,0xBe,0x0A,0x4d,0x52, // 1910-1912 
    0x0d,0x25,0x46,0x5d,0x52,0xBA,0x0B,0x54,0x4e, // 1913-1915 
    0x0d,0x6A,0x43,0x29,0x6d,0x37,0x09,0x5B,0x4B, // 1916-1918 
    0x74,0x9B,0xC1,0x04,0x97,0x54,0x0A,0x4B,0x48, // 1919-1921 
    0x5B,0x25,0xBC,0x06,0xA5,0x50,0x06,0xd4,0x45, // 1922-1924 
    0x4A,0xdA,0xB8,0x02,0xB6,0x4d,0x09,0x57,0x42, // 1925-1927 
    0x24,0x97,0xB7,0x04,0x97,0x4A,0x66,0x4B,0x3e, // 1928-1930 
    0x0d,0x4A,0x51,0x0e,0xA5,0x46,0x56,0xd4,0xBA, // 1931-1933 
    0x05,0xAd,0x4e,0x02,0xB6,0x44,0x39,0x37,0x38, // 1934-1936 
    0x09,0x2e,0x4B,0x7C,0x96,0xBf,0x0C,0x95,0x53, // 1937-1939 
    0x0d,0x4A,0x48,0x6d,0xA5,0x3B,0x0B,0x55,0x4f, // 1940-1942 
    0x05,0x6A,0x45,0x4A,0xAd,0xB9,0x02,0x5d,0x4d, // 1943-1945 
    0x09,0x2d,0x42,0x2C,0x95,0xB6,0x0A,0x95,0x4A, // 1946-1948 
    0x7B,0x4A,0xBd,0x06,0xCA,0x51,0x0B,0x55,0x46, // 1949-1951 
    0x55,0x5A,0xBB,0x04,0xdA,0x4e,0x0A,0x5B,0x43, // 1952-1954 
    0x35,0x2B,0xB8,0x05,0x2B,0x4C,0x8A,0x95,0x3f, // 1955-1957 
    0x0e,0x95,0x52,0x06,0xAA,0x48,0x7A,0xd5,0x3C, // 1958-1960 
    0x0A,0xB5,0x4f,0x04,0xB6,0x45,0x4A,0x57,0x39, // 1961-1963 
    0x0A,0x57,0x4d,0x05,0x26,0x42,0x3e,0x93,0x35, // 1964-1966 
    0x0d,0x95,0x49,0x75,0xAA,0xBe,0x05,0x6A,0x51, // 1967-1969 
    0x09,0x6d,0x46,0x54,0xAe,0xBB,0x04,0xAd,0x4f, // 1970-1972 
    0x0A,0x4d,0x43,0x4d,0x26,0xB7,0x0d,0x25,0x4B, // 1973-1975 
    0x8d,0x52,0xBf,0x0B,0x54,0x52,0x0B,0x6A,0x47, // 1976-1978 
    0x69,0x6d,0x3C,0x09,0x5B,0x50,0x04,0x9B,0x45, // 1979-1981 
    0x4A,0x4B,0xB9,0x0A,0x4B,0x4d,0xAB,0x25,0xC2, // 1982-1984 
    0x06,0xA5,0x54,0x06,0xd4,0x49,0x6A,0xdA,0x3d, // 1985-1987 
    0x0A,0xB6,0x51,0x09,0x37,0x46,0x54,0x97,0xBB, // 1988-1990 
    0x04,0x97,0x4f,0x06,0x4B,0x44,0x36,0xA5,0x37, // 1991-1993 
    0x0e,0xA5,0x4A,0x86,0xB2,0xBf,0x05,0xAC,0x53, // 1994-1996 
    0x0A,0xB6,0x47,0x59,0x36,0xBC,0x09,0x2e,0x50, // 1997-1999 
    0x0C,0x96,0x45,												 */
    0x4d,0x4A,0xB8,0x0d,0x4A,0x4C,                // 2001-2002 
    0x0d,0xA5,0x41,0x25,0xAA,0xB6,0x05,0x6A,0x49, // 2003-2005 
    0x7A,0xAd,0xBd,0x02,0x5d,0x52,0x09,0x2d,0x47, // 2006-2008 	  
    0x5C,0x95,0xBA,0x0A,0x95,0x4e,0x0B,0x4A,0x43, // 2009-2011 
    0x4B,0x55,0x37,0x0A,0xd5,0x4A,0x95,0x5A,0xBf, // 2012-2014 
    0x04,0xBA,0x53,0x0A,0x5B,0x48,0x65,0x2B,0xBC, // 2015-2017 
    0x05,0x2B,0x50,0x0A,0x93,0x45,0x47,0x4A,0xB9, // 2018-2020 
    0x06,0xAA,0x4C,0x0A,0xd5,0x41,0x24,0xdA,0xB6, // 2021-2023 
    0x04,0xB6,0x4A,0x69,0x57,0x3d,0x0A,0x4e,0x51, // 2024-2026 
    0x0d,0x26,0x46,0x5e,0x93,0x3A,0x0d,0x53,0x4d, // 2027-2029 
    0x05,0xAA,0x43,0x36,0xB5,0x37,0x09,0x6d,0x4B, // 2030-2032 
    0xB4,0xAe,0xBf,0x04,0xAd,0x53,0x0A,0x4d,0x48, // 2033-2035 
    0x6d,0x25,0xBC,0x0d,0x25,0x4f,0x0d,0x52,0x44, // 2036-2038 
    0x5d,0xAA,0x38,0x0B,0x5A,0x4C,0x05,0x6d,0x41, // 2039-2041 
    0x24,0xAd,0xB6,0x04,0x9B,0x4A,0x7A,0x4B,0xBe, // 2042-2044 
    0x0A,0x4B,0x51,0x0A,0xA5,0x46,0x5B,0x52,0xBA, // 2045-2047 
    0x06,0xd2,0x4e,0x0A,0xdA,0x42,0x35,0x5B,0x37, // 2048-2050
/*	 
    0x09,0x37,0x4B,0x84,0x97,0xC1,0x04,0x97,0x53, // 2051-2053 
    0x06,0x4B,0x48,0x66,0xA5,0x3C,0x0e,0xA5,0x4f, // 2054-2056 
    0x06,0xB2,0x44,0x4A,0xB6,0x38,0x0A,0xAe,0x4C, // 2057-2059 
    0x09,0x2e,0x42,0x3C,0x97,0x35,0x0C,0x96,0x49, // 2060-2062 
    0x7d,0x4A,0xBd,0x0d,0x4A,0x51,0x0d,0xA5,0x45, // 2063-2065 
    0x55,0xAA,0xBA,0x05,0x6A,0x4e,0x0A,0x6d,0x43, // 2066-2068 
    0x45,0x2e,0xB7,0x05,0x2d,0x4B,0x8A,0x95,0xBf, // 2069-2071 
    0x0A,0x95,0x53,0x0B,0x4A,0x47,0x6B,0x55,0x3B, // 2072-2074 
    0x0A,0xd5,0x4f,0x05,0x5A,0x45,0x4A,0x5d,0x38, // 2075-2077 
    0x0A,0x5B,0x4C,0x05,0x2B,0x42,0x3A,0x93,0xB6, // 2078-2080 
    0x06,0x93,0x49,0x77,0x29,0xBd,0x06,0xAA,0x51, // 2081-2083 
    0x0A,0xd5,0x46,0x54,0xdA,0xBA,0x04,0xB6,0x4e, // 2084-2086 
    0x0A,0x57,0x43,0x45,0x27,0x38,0x0d,0x26,0x4A, // 2087-2089 
    0x8e,0x93,0x3e,0x0d,0x52,0x52,0x0d,0xAA,0x47, // 2090-2092 
    0x66,0xB5,0x3B,0x05,0x6d,0x4f,0x04,0xAe,0x45, // 2093-2095 
    0x4A,0x4e,0xB9,0x0A,0x4d,0x4C,0x0d,0x15,0x41, // 2096-2098 
    0x2d,0x92,0xB5,                                // 2099
    */
};

//月份天数数据表
unsigned char  code day_code1[9]={0x0,0x1f,0x3b,0x5a,0x78,0x97,0xb5,0xd4,0xf3};
unsigned int code day_code2[3]={0x111,0x130,0x14e}; 
	

/****************************************************************************
* 子函数,用于读取数据表中农历月的大月或小月,如果该月为大返回1,为小返回0
*****************************************************************************/
	
unsigned char get_moon_day(unsigned char month_p,unsigned int code_addr)
{    
    unsigned char temp,temp1;    
    temp1=(month_p+3)/8;    
    temp=0x80>>((month_p+3)%8);    
    temp=year_code[code_addr+temp1]&temp;
 
    if(temp==0) return(0);
    else return(1);
}



/*********************************************************************************************************
** 函数名称:GetChinaCalendar
** 功能描述:公农历转换(只允许2000-2050年)
** 输　入:  year        公历年
**          *month       公历月
**          *day         公历日
						(输入输出共用，指针式读写月日)(年只读)
						比如GetChinaCalendar(&year, &month, &day)year = 14, month = 08, day = 17;
** 作　者:  Campo
** 修  改:  Wen
** 日　期:  2014年08月17日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
void GetChinaCalendar(unsigned char  year,	unsigned char *month_IO,	unsigned char *day_IO)
{       
		unsigned char  month,day;    
		unsigned char  temp1,temp2,temp3,month_p;    
    unsigned int temp4,code_addr;
    bit    flag_y;     
  
    month = *month_IO;    //加载年月日数据,如为BCD则需转为十进制    
    day   = *day_IO; 
  
		/*判断日期是正常的*/
		if((year > 50) || (month == 0) || (month > 12) || (day == 0) || (day > 31))return;
	
		/* 定位数据表地址 */
    code_addr  = year-1;
    code_addr *= 3;
	
		/* 取当年春节所在的公历月份 */
    temp1 = year_code[code_addr+2]&0x60;   //取当年春节所在的公历月份    
    temp1 >>= 5;              //进位右移
	
		/* 取当年春节所在的公历日*/
    temp2 = year_code[code_addr+2]&0x1f;   
     
		/*计算当年春节离当年元旦的天数,春节只会在公历1月或2月*/ 
		if(temp1==1) 	temp3=temp2-1; 
		else 			temp3=temp2+31-1;               //2月春节则天数加31   
		
		/*计算当日离元旦天数*/ 
    if(month<10) temp4 = day_code1[month-1]+day-1;
    else         temp4 = day_code2[month-10]+day-1;   
 
		/* 如果公历月大于2月并且该年的2月为闰月,天数加1 */
    if ((month>2)&&(year%4==0)) 	temp4++;

    /* 判断公历日在春节前还是春节后 *///公历日在春节后或就是春节当日使用下面代码进行运算 
    if (temp4 >= temp3)                
    {        
        temp4  -= temp3;        
        month   = 1;                
        flag_y  = 0;        
        month_p = 1;  //month_p为月份指向,公历日在春节前或就是春节当日month_p指向首月
	       
        if(get_moon_day(month_p,code_addr)==0) temp1 = 29;
        else temp1 = 30;  //小月29天、大月30天                   
        /* 从数据表中取该年的闰月月份,如为0则该年无闰月 */
        temp2=year_code[code_addr]/16;
		       
        while(temp4>=temp1)       
        {            
            temp4-=temp1;            
            month_p++;            
            if(month==temp2)    //闰月        
            {                
                flag_y=~flag_y;                
                if(flag_y==0) month++;            
            }            
            else month++;            
            
            if(get_moon_day(month_p,code_addr)==0) temp1=29;            
            else temp1=30;        
        }        
        day=temp4+1;		    
    }
		/* 公历日在春节前使用下面代码进行运算 */
    else     
    {          
        temp3-=temp4;        
        if(year==0) year=0xe3; //??
        else year-=1;         
        code_addr-=3;        
        month  = 12;    
    
        temp2=year_code[code_addr]/16;
				              
        if(temp2==0) month_p=12; //如果当年有闰月,一年有十三个月,月指向13,无闰月指向12          
        else month_p=13;
        flag_y = 0;
				                
        if(get_moon_day(month_p,code_addr)==0) temp1=29; 
        else temp1=30; 
	
        while(temp3>temp1)       
        {            
            temp3-=temp1;            
            month_p-=1;            
            if(flag_y==0) month-=1;            
            if(month==temp2) flag_y=~flag_y;            
			            
            if(get_moon_day(month_p,code_addr)==0) temp1=29;
            else temp1=30;        
        }        
        day=temp1-temp3+1;
		    
    }   
               
    *month_IO = month;    //将农历信息写进指定变量   
    *day_IO   = day;

}

/*********************************************************************************************************
**         以下为24节气计算相关程序
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/


/*  
    每年24节气标志表   
    有兴趣的朋友可按照上面给的原理添加其它年份的表格
    不是很清楚的朋友可给我发EMAIL
*/
/*
code unsigned char YearMonthBit[]=
{
	0x4E,0xA6,0x99,		//2000
	0x9C,0xA2,0x98,		//2001
	0x80,0x00,0x18,		//2002
	0x00,0x10,0x24,		//2003
	0x4E,0xA6,0x99,		//2004
	0x9C,0xA2,0x98,		//2005
	0x80,0x82,0x18,		//2006
	0x00,0x10,0x24,		//2007
	0x4E,0xA6,0xD9,		//2008
	0x9E,0xA2,0x98,		//2009

	0x80,0x82,0x18,		//2010
	0x00,0x10,0x04,		//2011
	0x4E,0xE6,0xD9,		//2012
	0x9E,0xA6,0xA8,		//2013
	0x80,0x82,0x18,		//2014
	0x00,0x10,0x00,		//2015
	0x0F,0xE6,0xD9,		//2016
	0xBE,0xA6,0x98,		//2017
	0x88,0x82,0x18,		//2018
	0x80,0x00,0x00,		//2019

	0x0F,0xEF,0xD9,		//2020
	0xBE,0xA6,0x99,		//2021
	0x8C,0x82,0x98,		//2022
	0x80,0x00,0x00,		//2023
	0x0F,0xEF,0xDB,		//2024
	0xBE,0xA6,0x99,		//2025
	0x9C,0xA2,0x98,		//2026
	0x80,0x00,0x18,		//2027
	0x0F,0xEF,0xDB,		//2028
	0xBE,0xA6,0x99,		//2029

	0x9C,0xA2,0x98,		//2030
	0x80,0x00,0x18,		//2031
	0x0F,0xEF,0xDB,		//2032
	0xBE,0xA2,0x99,		//2033
	0x8C,0xA0,0x98,		//2034
	0x80,0x82,0x18,		//2035
	0x0B,0xEF,0xDB,		//2036
	0xBE,0xA6,0x99,		//2037
	0x8C,0xA2,0x98,		//2038
	0x80,0x82,0x18,		//2039

	0x0F,0xEF,0xDB,		//2040
	0xBE,0xE6,0xD9,		//2041 
	0x9E,0xA2,0x98,		//2042
	0x80,0x82,0x18,		//2043
	0x0F,0xEF,0xFB,		//2044
	0xBF,0xE6,0xD9,		//2045
	0x9E,0xA6,0x98,		//2046
	0x80,0x82,0x18,		//2047
	0x0F,0xFF,0xFF,		//2048
	0xFC,0xEF,0xD9,		//2049
	0xBE,0xA6,0x18,		//2050
};
code unsigned char days[]=
{
	6,20,4,19,6,21,         //一月到三月  的节气基本日期
	5,20,6,21,6,21,         //四月到六月  的节气基本日期
	7,23,8,23,8,23,         //七月到九月  的节气基本日期
	8,24,8,22,7,22,         //十月到十二月的节气基本日期
};
*/
/*
code char JieQiStr[][5]=  //以公历日期先后排序
{
 /*  名称        角度    公历日期     周期 */
 /*
	"小寒",     //285     1月 6日
	"大寒",     //300     1月20日    29.5天
	"立春",     //315     2月 4日
	"雨水",     //330     2月19日    29.8天
	"惊蛰",     //345     3月 6日
	"春分",     //  0     3月21日    30.2天
	"清明",     // 15     4月 5日
	"谷雨",     // 30     4月20日    30.7天
	"立夏",     // 45     5月 6日
	"夏满",     // 60     5月21日    31.2天
	"芒种",     // 75     6月 6日
	"夏至",     // 90     6月21日    31.4天
	"小暑",     //105     7月 7日
	"大暑",     //120     7月23日    31.4天
	"立秋",     //135     8月 8日
	"处暑",     //150     8月23日    31.1天
	"白露",     //165     9月 8日
	"秋分",     //180     9月23日    30.7天
	"寒露",     //195    10月 8日
	"霜降",     //210    10月24日    30.1天
	"立冬",     //225    11月 8日
	"小雪",     //240    11月22日    29.7天
	"大雪",     //255    12月 7日
	"冬至",     //270    12月22日    29.5天
};
*/
/*********************************************************************************************************
** 函数名称:GetJieQi
** 功能描述:输入公历日期得到本月24节气日期 day<15返回上半月节气,反之返回下半月	
**          如:GetJieQiStr(07,02,08,str) 返回str[0]=4
** 输　入:  year        公历年(只接受AA == 00--50)20AA
**          month       公历月
**          day         公历日
**          str         储存对应本月节气日期地址   1Byte
** 输　出:  1           成功
**          0           失败
** 作　者:  赖皮        ★〓个人原创〓★
** 日　期:  2007年02月08日
**-------------------------------------------------------------------------------------------------------
** 修改人:	WEN
** 日　期:	2014年8月17日
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
/*
bit GetJieQi(
			unsigned  int year,
			unsigned char month,
			unsigned char day,
			unsigned char *JQdate)
{
	unsigned char bak1,value,JQ;

	if(year>50)     return 0;
	if((month==0) ||(month>12))      return 0;
	JQ = (month-1) *2 ;		                        //获得节气顺序标号(0～23
	if(day >= 15) JQ++; 	                        //判断是否是上半月

	bak1=YearMonthBit[year*3+JQ/8];          //获得节气日期相对值所在字节
	value =((bak1<<(JQ%8))&0x80);                   //获得节气日期相对值状态

	*JQdate=days[JQ];
	if( value != 0 )
	{
		//判断年份,以决定节气相对值1代表1,还是－1。
		if( (JQ== 1||JQ== 11||JQ== 18||JQ== 21)&&year< 2044)  (*JQdate)++;
		else                                                  (*JQdate)--;
	}
	return 1;
}
*/